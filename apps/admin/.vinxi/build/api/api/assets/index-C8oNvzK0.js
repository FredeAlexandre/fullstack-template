import{H3Event as h,getRequestURL as b,getRequestWebStream as x,eventHandler as _}from"h3";import{AsyncLocalStorage as v}from"node:async_hooks";function S(t={}){let e,o=!1;const i=n=>{if(e&&e!==n)throw new Error("Context conflict")};let r;if(t.asyncContext){const n=t.AsyncLocalStorage||globalThis.AsyncLocalStorage;n?r=new n:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const s=()=>{if(r&&e===void 0){const n=r.getStore();if(n!==void 0)return n}return e};return{use:()=>{const n=s();if(n===void 0)throw new Error("Context is not available");return n},tryUse:()=>s(),set:(n,a)=>{a||i(n),e=n,o=!0},unset:()=>{e=void 0,o=!1},call:(n,a)=>{i(n),e=n;try{return r?r.run(n,a):a()}finally{o||(e=void 0)}},async callAsync(n,a){e=n;const u=()=>{e=n},l=()=>e===n?u:void 0;y.add(l);try{const f=r?r.run(n,a):a();return o||(e=void 0),await f}finally{y.delete(l)}}}}function T(t={}){const e={};return{get(o,i={}){return e[o]||(e[o]=S({...t,...i})),e[o]}}}const p=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},d="__unctx__",A=p[d]||(p[d]=T()),E=(t,e={})=>A.get(t,e),m="__unctx_async_handlers__",y=p[m]||(p[m]=new Set);function H(t){let e;const o=R(t),i={duplex:"half",method:t.method,headers:t.headers};return t.node.req.body instanceof ArrayBuffer?new Request(o,{...i,body:t.node.req.body}):new Request(o,{...i,get body(){return e||(e=$(t),e)}})}function C(t){return t.web??={request:H(t),url:R(t)},t.web.request}function I(){return W()}const w=Symbol("$HTTPEvent");function L(t){return typeof t=="object"&&(t instanceof h||t?.[w]instanceof h||t?.__is_event__===!0)}function P(t){return function(...e){let o=e[0];if(L(o))e[0]=o instanceof h||o.__is_event__?o:o[w];else{if(!globalThis.app.config.server.experimental?.asyncContext)throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");if(o=I(),!o)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");e.unshift(o)}return t(...e)}}const R=P(b),$=P(x);function q(){return E("nitro-app",{asyncContext:!!globalThis.app.config.server.experimental?.asyncContext,AsyncLocalStorage:v})}function W(){return q().use().event}const B=[{path:"/__root",filePath:"/home/alex/Github/smartflow/apps/admin/app/routes/__root.tsx"},{path:"/first-launch",filePath:"/home/alex/Github/smartflow/apps/admin/app/routes/first-launch.tsx"},{path:"/",filePath:"/home/alex/Github/smartflow/apps/admin/app/routes/index.tsx"},{path:"/api/auth/*splat",filePath:"/home/alex/Github/smartflow/apps/admin/app/routes/api/auth/$.ts",$APIRoute:{src:"app/routes/api/auth/$.ts?pick=APIRoute",build:()=>import("../_.js"),import:()=>import("../_.js")}}],N=["GET","POST","PUT","PATCH","DELETE","OPTIONS","HEAD"];function M(t){return _(async e=>{const o=C(e);return await t({request:o})})}const D=t=>e=>({path:t,methods:e});function U(t,e){const o=t.pathname.split("/").filter(Boolean),i=e.sort((r,s)=>{const n=r.routePath.split("/").filter(Boolean);return s.routePath.split("/").filter(Boolean).length-n.length}).filter(r=>{const s=r.routePath.split("/").filter(Boolean);return o.length>=s.length});for(const r of i){const s=r.routePath.split("/").filter(Boolean),n={};let a=!0;for(let u=0;u<s.length;u++){const l=s[u],f=o[u];if(l.startsWith("$"))if(l==="$"){const c=o.slice(u).join("/");if(c!=="")n["*"]=c,n._splat=c;else{a=!1;break}}else{const c=l.slice(1);n[c]=f}else if(l!==f){a=!1;break}}if(a)return{routePath:r.routePath,params:n,payload:r.payload}}}const g=B.filter(t=>t.$APIRoute);function F(t){const e=[];return t.forEach(o=>{const r=o.path.split("/").filter(Boolean).map(s=>s==="*splat"?"$":s.startsWith(":$")&&s.endsWith("?")?s.slice(1,-1):s).join("/");e.push({routePath:`/${r}`,payload:o})}),e}const K=async({request:t})=>{if(!g.length)return new Response("No routes found",{status:404});if(!N.includes(t.method))return new Response("Method not allowed",{status:405});const e=F(g),o=new URL(t.url,"http://localhost:3000"),i=U(o,e);if(!i)return new Response("Not found",{status:404});let r;try{r=await i.payload.$APIRoute.import().then(a=>a.APIRoute)}catch(a){return console.error("Error importing route file:",a),new Response("Internal server error",{status:500})}if(!r)return new Response("Internal server error",{status:500});const s=t.method,n=r.methods[s];return n?await n({request:t,params:i.params}):new Response("Method not allowed",{status:405})};export{D as a,M as c,K as d};
